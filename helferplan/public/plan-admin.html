<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Admin: Zeitblöcke verwalten</title>
  <link rel="stylesheet" href="css/style.css">
  <style>
    html, body { overflow-x: hidden; }
    .plan-main { max-width: 1200px; margin: 0 auto; }
    .plan-layout { display: flex; gap: 12px; align-items: flex-start; }
    .left-panel { width: 240px; flex: 0 0 240px; }

    #plan-container { overflow-x: auto; flex: 1 1 auto; position: relative; }
    #timeline-header { position: sticky; top: 0; background: #fff; z-index: 10; display:block; }

    /* wichtig: alle relevant boxen box-sizing border-box */
    #timeline-header, #grid-container, .hour-slot, .shift-slot, .activity-name { box-sizing: border-box; }

    .hour-slot { font-size:12px; padding:4px 6px; text-align:center; background:#fafafa; }
    .shift-slot { font-size:12px; padding:6px; min-height:36px; display:flex; align-items:center; justify-content:center; cursor:pointer; overflow:hidden; transition: transform .08s, outline .08s; }
    .shift-slot.filled { color:#fff; }

    .dimmed { opacity: .28; filter: grayscale(80%); }

    .shift-slot.potential-drop { outline:3px dashed rgba(33,150,243,0.9); transform: translateY(-1px); box-shadow:0 0 0 3px rgba(33,150,243,0.04) inset; }
    .shift-slot.drop-target { outline:3px solid rgba(33,150,243,0.95); transform: translateY(-2px); box-shadow:0 0 0 3px rgba(33,150,243,0.08) inset; }

    .slot-hidden { display:none !important; }

    /* die linke placeholder-zelle im header (falls sichtbar) auf transparent setzen */
    .left-placeholder { background: transparent !important; }

    /* Die linke Spalte (activity name) ist sticky, Teil des selben Grids */
    .activity-name {
      background: #fff;
      position: sticky;
      left: 0;
      z-index: 5;
      padding: 8px;
      border-right: 1px solid #e6e6e6;
      min-height: 36px;
      display:flex;
      align-items:center;
      font-weight:600;
    }

    .activity-group-header { padding:8px 0 4px 0; font-weight:700; grid-column:1 / -1; background: transparent; }
    #grid-container { overflow: visible; }
  </style>
</head>
<body>
<nav>
  <a href="index.html" class="active">Admin: Stammdaten</a>
  <a href="plan.html">Turnier-Planung</a>
  <a href="plan-admin.html">Turnier-Admin</a>
</nav>

<main class="plan-main">
  <h1>Admin: Zeitblöcke verwalten</h1>
  <div class="plan-layout">
    <div class="left-panel">
      <h3>Aktivitäten</h3>
      <div id="activity-list"></div>
    </div>

    <div id="plan-container">
      <div id="timeline-header" aria-hidden="true"></div>
      <div id="grid-container" role="grid"></div>
    </div>
  </div>
</main>

<script src="/helferplan/public/config.js"></script>
<script>
  document.addEventListener('DOMContentLoaded', async () => {
    // API base for Helferplan - same as plan.js
    const API_URL_HELFERPLAN = (() => {
        const meta = document.querySelector('meta[name="api-url-helferplan"]');
        if (meta && meta.content) return meta.content.replace(/\/$/, '');
        if (window.__API_URL_HELFERPLAN) return String(window.__API_URL_HELFERPLAN).replace(/\/$/, '');
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            return `${window.location.protocol}//${window.location.hostname}:3003/api`;
        }
        return `${window.location.origin}/api`;
    })();
    window.API_URL_HELFERPLAN = API_URL_HELFERPLAN;
    console.info('API_URL_HELFERPLAN =', API_URL_HELFERPLAN);

    const timelineHeader = document.getElementById('timeline-header');
    const gridContainer = document.getElementById('grid-container');
    const activityList = document.getElementById('activity-list');

    // Config - match plan.js
    const HOUR_PX = 40;
    const LEFT_COL_PX = 200;

    let activities = [];
    let allowedBlocks = {};
    let isDragging = false;
    let dragMode = null; // 'lock' or 'unlock'

    async function fetchActivities() {
      const res = await fetch(`${API_URL_HELFERPLAN}/activities`);
      if (!res.ok) throw new Error('Fehler beim Laden der Aktivitäten');
      activities = await res.json();
      
      // Group activities
      const groups = activities.reduce((acc, a) => {
        const g = a.group_name || 'Ohne Gruppe';
        (acc[g] || (acc[g]=[])).push(a);
        return acc;
      }, {});

      // Render activity list
      activityList.innerHTML = '';
      for (const groupName in groups) {
        const groupDiv = document.createElement('div');
        groupDiv.style.marginBottom = '8px';
        const groupLabel = document.createElement('strong');
        groupLabel.textContent = groupName;
        groupDiv.appendChild(groupLabel);
        activityList.appendChild(groupDiv);
        
        groups[groupName].forEach(activity => {
          const actDiv = document.createElement('div');
          actDiv.style.paddingLeft = '12px';
          actDiv.textContent = activity.name;
          activityList.appendChild(actDiv);
        });
      }
    }

    async function fetchAllowedBlocks() {
      for (const activity of activities) {
        const res = await fetch(`${API_URL_HELFERPLAN}/activities/${activity.id}/allowed-time-blocks`);
        allowedBlocks[activity.id] = await res.json();
      }
    }

    function generateTimeline() {
      const hoursCountByDay = [12, 24, 18]; // Fr 12-24, Sa 0-24, So 0-18
      const days = ['Freitag','Samstag','Sonntag'];
      const totalHours = hoursCountByDay.reduce((a,b)=>a+b,0);
      const gridTemplateColumns = `${LEFT_COL_PX}px repeat(${totalHours}, ${HOUR_PX}px)`;

      timelineHeader.innerHTML = '';
      timelineHeader.style.display = 'grid';
      timelineHeader.style.gridTemplateColumns = gridTemplateColumns;
      timelineHeader.style.gridGap = '0';
      timelineHeader.style.paddingLeft = '0';
      timelineHeader.style.paddingInlineStart = '0';

      // Left placeholder
      const placeholder = document.createElement('div');
      placeholder.className = 'left-placeholder';
      placeholder.style.background = 'transparent';
      placeholder.style.margin = '0';
      placeholder.style.padding = '0';
      placeholder.style.width = `${LEFT_COL_PX}px`;
      placeholder.style.minWidth = `${LEFT_COL_PX}px`;
      placeholder.style.maxWidth = `${LEFT_COL_PX}px`;
      timelineHeader.appendChild(placeholder);

      // Days wrapper
      const daysWrapper = document.createElement('div');
      daysWrapper.style.display = 'grid';
      daysWrapper.style.gridTemplateColumns = `repeat(${totalHours}, ${HOUR_PX}px)`;
      daysWrapper.style.gridColumn = '2 / -1';
      daysWrapper.style.gap = '0';

      let offset = 0;
      hoursCountByDay.forEach((count, idx) => {
        const dh = document.createElement('div');
        dh.className = 'day-header';
        dh.style.gridColumn = `${offset+1} / ${offset+1+count}`;
        dh.style.textAlign = 'center';
        dh.style.padding = '6px 0';
        dh.textContent = days[idx] || '';
        daysWrapper.appendChild(dh);
        offset += count;
      });
      timelineHeader.appendChild(daysWrapper);

      // Hours wrapper
      const hoursWrapper = document.createElement('div');
      hoursWrapper.style.display = 'grid';
      hoursWrapper.style.gridTemplateColumns = `repeat(${totalHours}, ${HOUR_PX}px)`;
      hoursWrapper.style.gridColumn = '2 / -1';
      hoursWrapper.style.gap = '0';
      for (let i=0;i<totalHours;i++){
        const hour = document.createElement('div');
        hour.className = 'hour-slot';
        hour.textContent = `${(12 + i) % 24}:00`;
        hoursWrapper.appendChild(hour);
      }
      timelineHeader.appendChild(hoursWrapper);

      return { totalHours, gridTemplateColumns };
    }

    function isHourLocked(activityId, hour) {
      const blocks = allowedBlocks[activityId] || [];
      // A slot is "unlocked" if there's a block covering it
      // We'll use inverse logic: locked = NOT in any allowed block
      return !blocks.some(block => hour >= block.start && hour < block.end);
    }

    async function toggleSlotLock(activityId, hour, lockState) {
      const blocks = allowedBlocks[activityId] || [];
      
      if (lockState === 'unlock') {
        // Add to allowed blocks (unlock the slot)
        // Merge adjacent blocks
        let merged = false;
        for (let i = 0; i < blocks.length; i++) {
          if (blocks[i].end === hour) {
            blocks[i].end = hour + 1;
            merged = true;
            // Check if we can merge with next block
            for (let j = i + 1; j < blocks.length; j++) {
              if (blocks[j].start === blocks[i].end) {
                blocks[i].end = blocks[j].end;
                blocks.splice(j, 1);
                break;
              }
            }
            break;
          } else if (blocks[i].start === hour + 1) {
            blocks[i].start = hour;
            merged = true;
            break;
          }
        }
        if (!merged) {
          blocks.push({ start: hour, end: hour + 1 });
        }
      } else {
        // Remove from allowed blocks (lock the slot)
        for (let i = blocks.length - 1; i >= 0; i--) {
          const block = blocks[i];
          if (hour >= block.start && hour < block.end) {
            if (hour === block.start && hour + 1 === block.end) {
              // Remove entire block
              blocks.splice(i, 1);
            } else if (hour === block.start) {
              // Trim from start
              block.start = hour + 1;
            } else if (hour + 1 === block.end) {
              // Trim from end
              block.end = hour;
            } else {
              // Split block
              const newBlock = { start: hour + 1, end: block.end };
              block.end = hour;
              blocks.push(newBlock);
            }
            break;
          }
        }
      }

      // Send to server
      await fetch(`${API_URL_HELFERPLAN}/activities/${activityId}/allowed-time-blocks`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ blocks: blocks, password: '1881' })
      });
      
      allowedBlocks[activityId] = blocks;
    }

    function renderGrid(timelineConfig) {
      const groups = activities.reduce((acc, a) => {
        const g = a.group_name || 'Ohne Gruppe';
        (acc[g] || (acc[g]=[])).push(a);
        return acc;
      }, {});

      gridContainer.innerHTML = '';

      for (const groupName in groups) {
        const groupHeader = document.createElement('div');
        groupHeader.className = 'activity-group-header';
        groupHeader.textContent = groupName;
        gridContainer.appendChild(groupHeader);

        groups[groupName].forEach(activity => {
          const row = document.createElement('div');
          row.className = 'activity-row';
          row.style.display = 'grid';
          row.style.gridTemplateColumns = timelineConfig.gridTemplateColumns;
          row.style.gridGap = '0';

          const nameCell = document.createElement('div');
          nameCell.className = 'activity-name';
          nameCell.textContent = activity.name;
          row.appendChild(nameCell);

          for (let i = 0; i < timelineConfig.totalHours; i++) {
            const slot = document.createElement('div');
            slot.className = 'shift-slot';
            slot.dataset.activityId = activity.id;
            slot.dataset.hourIndex = i;

            const locked = isHourLocked(activity.id, i);
            if (locked) {
              slot.style.backgroundColor = '#ccc';
              slot.style.opacity = '0.5';
              slot.title = 'Gesperrt (klicken zum Entsperren)';
            } else {
              slot.style.backgroundColor = '#90EE90';
              slot.style.opacity = '1';
              slot.title = 'Freigeschaltet (klicken zum Sperren)';
            }

            // Mouse events for drag-to-paint
            slot.addEventListener('mousedown', (e) => {
              e.preventDefault();
              isDragging = true;
              const currentlyLocked = isHourLocked(activity.id, i);
              dragMode = currentlyLocked ? 'unlock' : 'lock';
              toggleSlotLock(activity.id, i, dragMode).then(() => {
                updateSlotVisual(slot, activity.id, i);
              });
            });

            slot.addEventListener('mouseenter', (e) => {
              if (isDragging && dragMode) {
                toggleSlotLock(activity.id, i, dragMode).then(() => {
                  updateSlotVisual(slot, activity.id, i);
                });
              }
            });

            row.appendChild(slot);
          }
          gridContainer.appendChild(row);
        });
      }

      // Global mouse up to stop dragging
      document.addEventListener('mouseup', () => {
        isDragging = false;
        dragMode = null;
      });
    }

    function updateSlotVisual(slot, activityId, hour) {
      const locked = isHourLocked(activityId, hour);
      if (locked) {
        slot.style.backgroundColor = '#ccc';
        slot.style.opacity = '0.5';
        slot.title = 'Gesperrt (klicken zum Entsperren)';
      } else {
        slot.style.backgroundColor = '#90EE90';
        slot.style.opacity = '1';
        slot.title = 'Freigeschaltet (klicken zum Sperren)';
      }
    }

    await fetchActivities();
    await fetchAllowedBlocks();
    const timelineConfig = generateTimeline();
    renderGrid(timelineConfig);
  });
</script>
</body>
</html>